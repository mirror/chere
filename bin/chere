#!/bin/sh
#
# This shell script manages Cygwin Prompt Here functionality.
# Requires: regtool, uname, id, cygpath, getopt, bash, sed, wc
#
# TODO
# ----
# 1. Use runas to make sure regtool has the right privileges when installing for all users
#	Would need to call myself with runas so the user only enters pwd once.
#
# KNOWN ERRORS
#
# cmd and command cannot cd to network paths like \\server\share.
#
# Dave Kilroy
# Oct 2004
#
VERSION=0.5
#	Add back -a and -c options to set options in HKCU
#	Make sure the appropriate entries are uninstalled when run. Obey -a and -c options
#	Note a user can't uninstall for another user
#	Remove reference to -x that sneaked into help
#	Rationalize help as chere now has a man page
#	sed now required to parse XX_KEYS and ensure they exist
#VERSION=0.4
#	Add r to synopsis
#	Remove redundant TERM_CMDs and CYG_DIR
#	Use run.exe if I can find it
#	Add -1 and -2 options to determine how to start the shell. 2 is default
#	-2 fixes reported issues with network paths and tcsh/ash login shells
#		Thanks to Igor Petchanksi, Andrew Grimm, Munehiro (haro) Matsuda
#	-2 untested on XP/NT/95/98/ME
#VERSION=0.3
#	Use forward slashes for command to fix XP problems (CGF)
#	Correct quoting (CGF)
#	Add -r option to read registry entries to stdout to help debugging
#VERSION=0.2
#	Use consistent registry key based on shell id
#	Fixup windows version check
#	Use correct cmd/command quoting
#	Add list option, install is no longer default
#	Check regtool/sed is present
#	Add xterm -e arg
#	Check the term/shell is present before installing (except cmd)
#	Add information on window title and login shells
#	Set pdksh, tcsh, zsh to start login shells
#	Case statements ash compatible
#	Look in passwd for shell if not specified
#	Mental runtime check of passwd added. Use at own risk
#	Changed to use getopt and removed [[ ]] tests. Ash compatible.
#	Updated shebang
#VERSION=0.1
#	Initial implementation.
#	Bash required.
#	Possible quoting problems.
#	Windows uninstall only posible if script present

# Need to use eval to force correct quote evaluation
REGTOOL="eval regtool"
REGTOOL_=regtool

KNOWN_TERMS="cmd rxvt xterm"
KNOWN_SHELLS="ash bash cmd pdksh tcsh zsh passwd"

ALL_USERS=unset
ACTION=nothing
DO_WIN_UINST=t
FORCE=f
LIST=f
READ=f
METHOD=2
PRINT=f
# Used to set an extra argument for Control Panel uninstall for current user
UINST_ARG=""

# Default terminal and shell if not specified
this_term=cmd
#this_shell=passwd

####################### Parse command line #######################
GETOPTED_ARGS=`getopt -u -o iulracnmpf12ht:s: -- $*`
set -- $GETOPTED_ARGS
for ARG; do
  case $ARG in
    -i ) shift; ACTION=i;;
    -u ) shift; ACTION=u;;
    -l ) shift; LIST=t;;
    -r ) shift; READ=t;;
    -a ) shift; ALL_USERS=t;;
    -c ) shift; ALL_USERS=f;;
    -n ) shift; DO_WIN_UINST=t;;
    -m ) shift; DO_WIN_UINST=f;;
    -p ) shift; REGTOOL="echo regtool"; PRINT=t;;
    -f ) shift; FORCE=t;;
    -1 ) shift; METHOD=1;;
    -2 ) shift; METHOD=2;;
    -t ) shift; this_term=$1; shift;;
    -s ) shift; this_shell=$1; shift;;
    -h ) shift; cat <<-EOF
	$0 version $VERSION

	Usage:
	$0 -<iulr> [-lracnmpf12h] [-t <term>] [-s <shell>]

	Adds the stated terminal/shell combination to the folder context menu
	This allows you to right click a folder in Windows Explorer and open
	a Cygwin shell in that folder.

	Options:
	  i - Install
	  u - Uninstall
	  l - List currently installed Shell Here
	  r - Read all chere registry entries to stdout
	  a - All users
	  c - Current user only
	  n - Be Nice and provide Control Panel uninstall option (Default)
	  m - Minimal, no Control Panel uninstall
	  p - Print regtool commands to stdout rather than running them
	  f - Force write (overwrite existing, ignore missing files)
	  1 - Start using registry one-liners. This doesn't work with ash,
	      tcsh or network shares.
	  2 - Start via bash script. Relies on windows to change directory,
	      and login scripts avoiding doing a cd $HOME 
	  h - Help

	  t <term> - Use terminal term. Supported terminals are:
		$KNOWN_TERMS

	  s <shell> - Use the named shell. Supported shells are:
		$KNOWN_SHELLS

	See the man page for more detail.
	EOF
	# Handle unclosed quote for syntax highlighting '
	exit;;
  esac
done

# Quick check of common utilities (from sh-utils, cygwin, textutils packages)
if [ ! -x /bin/uname ] || [ ! -x /bin/cygpath ] || [ ! -x /bin/id ] || [ ! -x /bin/wc ] || [ ! -x /bin/sed ] ; then
 echo $0 Error: uname / id / cygpath / wc / sed not found
 echo These tools are required for correct operation. Aborting
 exit
fi

# Check windows version and cygwin install directory
VER=`uname -s`
ID_USER=`id -nu`
RUN_EXE=""
ASH_EXE=`cygpath -w /bin/sh`
BASH_EXE=`cygpath -w /bin/bash`

if [ -x /bin/which ]; then
 # Enable prepending of run.exe if we can find it.
 # I'm assuming run has been placed in the path.
 # We are doing this because run.exe is currently packaged in X-startup-scripts.
 # It is also likely that many non-X users will have run available on their path.
 # If and when run.exe migrates to cygutils, this will still work.
 #
 # However when that happens, anyone using the run command will need to rerun
 # chere to pick up the new path to run.
 RUN_EXE=`which run.exe 2>/dev/null`
 if [ -n "$RUN_EXE" ]; then
  # Convert to windows path
  RUN_EXE=`cygpath -w "$RUN_EXE"`
 fi
fi

# Check we have regtool (from cygwin package)
if [ ! -x /bin/regtool ]; then
 echo $0 Error: /bin/regtool not found
 echo
 echo You need regtool installed for this script to work.
 echo Aborting.
 exit
fi

# Identify the registry keys for each OS and desired set of users
# Same for all?
# Note that the entry /HKCU/Software/Classes may not exist, and may need
# to be created for the user.
DIR_KEY_CR=/HKCR/Directory/Shell
DRIVE_KEY_CR=/HKCR/Drive/Shell
DIR_KEY_CU=/HKCU/Software/Classes/Directory/Shell
DRIVE_KEY_CU=/HKCU/Software/Classes/Drive/Shell
UINST_KEY=/HKLM/Software/Microsoft/Windows/CurrentVersion/Uninstall
# Should also check if regtool will write
if [ $ALL_USERS = f ]; then
 DIR_KEY=$DIR_KEY_CU
 DRIVE_KEY=$DRIVE_KEY_CU
 UINST_ARG="-c"
else
 # all users is the default
 DIR_KEY=$DIR_KEY_CR
 DRIVE_KEY=$DRIVE_KEY_CR
fi

if [ $ACTION = i ]; then

 # If no shell specified at this stage, grab one from /etc/passwd if it is present
 if [ ! $this_shell ]; then
  if [ -f /etc/passwd ]; then
   this_shell=`sed -n "s?$ID_USER:.*:/bin/\(.*\)?\1?gp" /etc/passwd`
   echo Shell defaulting to $this_shell defined for $ID_USER
  else
   echo $0 Error: No shell specified, and /etc/passwd not present
   echo
   echo Can\'t guess what shell you want.
   echo Use -s to specify the shell.
   exit
  fi
 fi

 #################### Define terminals ########################
 # For each terminal, indicate the executable in TERM_EXE.
 # Unless it is cmd, it is assumed that -e passes the startup
 # command
 case $this_term in
  cmd )
	case $VER in
	CYGWIN_NT* )
	 TERM_EXE=cmd.exe;;
	* )
	 TERM_EXE=command.com;;
	esac;;
  rxvt )
	TERM_EXE="/bin/rxvt.exe";;
  xterm )
	TERM_EXE="/bin/xterm.exe";;
  * )
	echo $0 Error: Unknown terminal $this_term
	echo
	echo Supported terminals:
	echo $KNOWN_TERMS
	echo
	echo Use -h for help
	exit;;
 esac

 #################### Define shells #############################
 # For each shell, specify:
 # the command that should be used to start it in the directory %1, and keep it open.
 # the location of the executable to be checked on install
 # the accelerator to be displayed on the menu
 # the description text to be displayed in control panel uninstall window
 case $this_shell in
  bash )
	SHELL_EXE="/bin/bash.exe"
	SHELL_CMD="-l -c \\\"cd '%L'; exec $SHELL_EXE\\\""
	ACCEL="&Bash Here"
	CPH_DESC="Cygwin Bash Prompt Here";;
  ash )
	# TODO How to make this a login shell? Is -l undocumented?
	SHELL_EXE="/bin/sh.exe"
	SHELL_CMD="-c \\\"cd '%L'; exec $SHELL_EXE\\\"";
	ACCEL="&Ash Here"
	CPH_DESC="Cygwin Ash Prompt Here";;
  pdksh )
	SHELL_EXE="/bin/pdksh.exe"
	SHELL_CMD="-l -c \\\"cd '%L'; exec $SHELL_EXE\\\""
	ACCEL="&Pdksh Here"
	CPH_DESC="Cygwin Pdksh Prompt Here";;
  tcsh )
	# Apparently -l only applies if it is the only argument
	# so this may not work
	SHELL_EXE="/bin/tcsh.exe"
	SHELL_CMD="-l -c \\\"cd '%L'; exec $SHELL_EXE\\\""
	ACCEL="&Tcsh Here"
	CPH_DESC="Cygwin Tcsh Prompt Here";;
  zsh )
	SHELL_EXE="/bin/zsh.exe"
	SHELL_CMD="-l -c \\\"cd '%L'; exec $SHELL_EXE\\\""
	ACCEL="&Zsh Here"
	CPH_DESC="Cygwin Zsh Prompt Here";;
  cmd )
	case $VER in
	CYGWIN_NT* )
	 SHELL_EXE=cmd.exe
	 SHELL_CMD="/k cd %L";;
	* )
	 SHELL_EXE=command.com
	 SHELL_CMD="/k cd \\\"%1\\\"";;
	esac
	ACCEL="&Command Prompt Here"
	CPH_DESC="Command Prompt Here (cygwin)";;
  passwd )
	# Experimental
	SHELL_EXE="/bin/sh"
	# Quoting nightmare. Step through it all
	# c:\cygwin\bin\sh -c "scmd=`sed -n \"s?\`id -un\`:.*:\\\(.*\\\)?\\\1?gp\" /etc/passwd`; $scmd -l -c \"cd 'c:/program files'; exec $scmd\""
	# works from the command line
	# In registry it needs to read the same:
	# c:\cygwin\bin\sh -c "scmd=`sed -n \"s?\`id -un\`:.*:\\\(.*\\\)?\\\1?gp\" /etc/passwd`; $scmd -l -c \"cd '%1'; exec $scmd\""
	# When passed to regtool, need to requote for the shell:
	# "c:\cygwin\bin\sh -c \"scmd=\`sed -n \\\"s?\\\`id -un\\\`:.*:\\\\\\(.*\\\\\\)?\\\\\\1?gp\\\" /etc/passwd\`; \$scmd -l -c \\\"cd '%1'; exec \$scmd\\\"\""
	# When evaluated into a variable, need another level of quoting:
	# "c:\cygwin\bin\sh -c \\\"scmd=\\\`sed -n \\\\\\\"s?\\\\\\\`id -un\\\\\\\`:.*:\\\\\\\\\\\\(.*\\\\\\\\\\\\)?\\\\\\\\\\\\1?gp\\\\\\\" /etc/passwd\\\`; \\\$scmd -l -c \\\\\\\"cd '%1'; exec \\\$scmd\\\\\\\"\\\""
	# Ouch. If you think it can be quoted better, let me know.
	SHELL_CMD="-c \\\"scmd=\\\`sed -n \\\\\\\"s?\\\\\\\`id -un\\\\\\\`:.*:\\\\\\\\\\\\(.*\\\\\\\\\\\\)?\\\\\\\\\\\\1?gp\\\\\\\" /etc/passwd\\\`; \\\$scmd -l -c \\\\\\\"cd '%L'; exec \\\$scmd\\\\\\\"\\\""
	ACCEL="Shell Prompt &Here"
	CPH_DESC="Cygwin Prompt Here"

	# Extra check before installing passwd
	if [ ! -f /etc/passwd ]; then
	 if [ $FORCE = t ]; then
	  echo $0 Warning: /etc/passwd not found
	  echo
	  echo This file is required for the runtime context menu item to work.
	  echo Run mkpasswd
	 else
	  echo $0 Error: /etc/passwd not found
	  echo
	  echo This file is required for the runtime context menu item to work.
	  echo Run mkpasswd to initialise the file.
	  echo Use -f to install anyway.
	  exit
	 fi
	fi;;
  * )
	echo $0 Error: Unknown shell $this_shell
	echo
	echo Supported shells:
	echo $KNOWN_SHELLS
	echo
	echo Use -h for help
	exit;;
 esac

 # Check TERM and SHELL are present
 if [ ! -x "$TERM_EXE" ] && [ "$this_term" != cmd ]; then
  if [ $FORCE = t ]; then
   echo $0 Warning: $TERM_EXE not found
  else
   echo $0 Error: $TERM_EXE not found
   echo
   echo $TERM_EXE is where I expect to find your $this_term
   echo Use -f to install anyway.
   exit
  fi
 fi
 if [ ! -x "$SHELL_EXE" ] && [ "$this_shell" != cmd ]; then
  if [ $FORCE = t ]; then
   echo $0 Warning: $SHELL_EXE not found
  else
   echo $0 Error: $SHELL_EXE not found
   echo
   echo $SHELL_EXE is where I expect to find $this_shell
   echo Use -f to install anyway.
   exit
  fi
 fi

 # TERM_EXE needs to be called by a windows path, even from run.exe
 TERM_WIN_EXE=`cygpath -w "$TERM_EXE"`
 if [ $METHOD = 1 ]; then
  if [ $this_term != cmd ]; then
   if [ -n "$RUN_EXE" ]; then
    START_CMD="$RUN_EXE $TERM_WIN_EXE -e $SHELL_EXE"
   else
    START_CMD="$TERM_WIN_EXE -e $SHELL_EXE"
   fi
  elif [ $this_shell != cmd ]; then
   # With cmd (term), the shell executable needs to be converted to a windows path
   # With cmd, we ignore TERM_CMD.
   START_CMD=`cygpath -w "$SHELL_EXE"`
  else
   # term and shell are cmd
   START_CMD=$SHELL_EXE
  fi
 else
  # METHOD 2
  XHERE="/bin/xhere"
  SHELL_CMD=""
  if [ $this_shell = cmd ]; then
   # Clear XHERE for when running command from rxvt/xterm
   XHERE="";
  elif [ $this_shell = passwd ]; then
   # Have XHERE do the call rather than bung it in the registry
   SHELL_EXE="/etc/passwd"
  fi
  
  if [ $this_term != cmd ]; then
   if [ -n "$RUN_EXE" ]; then
    START_CMD="$RUN_EXE $TERM_WIN_EXE -e $XHERE $SHELL_EXE"
   else
    START_CMD="$TERM_WIN_EXE -e $XHERE $SHELL_EXE"
   fi
  elif [ $this_shell != cmd ]; then
   START_CMD="`cygpath -w \"$BASH_EXE\"` -c \\\"$XHERE $SHELL_EXE\\\""
  else
   # The command shell won't cd anywhere anyway
   START_CMD=$SHELL_EXE
  fi
 fi

 ####### Install ###########
 if [ $FORCE = t ] || ! $REGTOOL_ check $DRIVE_KEY/cygwin_$this_shell 2> /dev/null ; then
  # Make sure the KEY exists
  KEY_ELEMENTS=`echo $DRIVE_KEY | sed "s?/? ?g"`
  CUR_KEY=
  for elem in $KEY_ELEMENTS; do
   CUR_KEY=$CUR_KEY/$elem
   if ! $REGTOOL_ check $CUR_KEY 2>/dev/null ; then
    # elem not present, so add it
    if ! $REGTOOL add $CUR_KEY ; then
     echo $0 Error: Hive not writable
     echo Aborting.
     exit
    fi
   fi
  done

  # Add Registry Key for Drives
  if ! $REGTOOL add $DRIVE_KEY/cygwin_$this_shell ; then
   echo $0 Error: Hive not writable
   echo Aborting.
   exit
  fi
  $REGTOOL -s set $DRIVE_KEY/cygwin_$this_shell/ \"$ACCEL\"
  $REGTOOL add $DRIVE_KEY/cygwin_$this_shell/command
  $REGTOOL -s set $DRIVE_KEY/cygwin_$this_shell/command/ \"$START_CMD $SHELL_CMD\"
 else
  echo $0 Warning: Not overriding existing entry
  echo
  echo Entry for $this_shell already exists in the Registry Drive Key
  echo Use -f to override existing key.
  echo
 fi

 if [ $FORCE = t ] || ! $REGTOOL_ check $DIR_KEY/cygwin_$this_shell 2> /dev/null; then
  # Make sure the KEY exists
  KEY_ELEMENTS=`echo $DIR_KEY | sed "s?/? ?g"`
  CUR_KEY=
  for elem in $KEY_ELEMENTS; do
   CUR_KEY=$CUR_KEY/$elem
   if ! $REGTOOL_ check $CUR_KEY 2>/dev/null ; then
    # elem not present, so add it
    if ! $REGTOOL add $CUR_KEY ; then
     echo $0 Error: Hive not writable
     echo Aborting.
     exit
    fi
   fi
  done

  # Add Registry Key for Directories/Folders
  if ! $REGTOOL add $DIR_KEY/cygwin_$this_shell ; then
   echo $0 Error: Hive not writable
   echo Aborting.
   exit
  fi

  $REGTOOL -s set $DIR_KEY/cygwin_$this_shell/ \"$ACCEL\"
  $REGTOOL add $DIR_KEY/cygwin_$this_shell/command
  $REGTOOL -s set $DIR_KEY/cygwin_$this_shell/command/ \"$START_CMD $SHELL_CMD\"
 else
  echo $0 Warning: Not overriding existing entry
  echo
  echo Entry for $this_shell already exists in the Registry Directory Key
  echo Use -f to override existing key.
  echo
 fi

 if [ $DO_WIN_UINST = t ]; then
  # Add uninstall registry entry
  if [ $FORCE = t ] || ! $REGTOOL_ check $UINST_KEY/cygwin_$this_shell 2> /dev/null ; then
   # Actually, should create an .inf so windows can get rid of the menu entries
   # even after the cygwin directory is wiped :(
   if $REGTOOL add $UINST_KEY/cygwin_$this_shell ; then
    $REGTOOL -s set $UINST_KEY/cygwin_$this_shell/DisplayName \"$CPH_DESC\"
    $REGTOOL -s set $UINST_KEY/cygwin_$this_shell/UnInstallString \"$ASH_EXE -c \\\"/bin/chere $UINST_ARG -u -s $this_shell\\\"\"
   else
    echo $0 Error: Couldn\'t modify HKLM hive.
    echo Control Panel uninstall will not be available.
   fi
  else
   echo $0 Warning: Not overriding existing entry
   echo
   echo Entry for $this_shell already exists in the Registry uninstall section
   echo Use -f to override existing key.
   echo
  fi
 fi
elif [ $ACTION = u ]; then
###### UnInstall ##########
 if [ $ALL_USERS = t ]; then
  # Don't remove HKCU entries
  DRIVE_KEYS=$DRIVE_KEY_CR
  DIR_KEYS=$DIR_KEY_CR
 elif [ $ALL_USERS = f ]; then
  # Don't remove HKCR entries
  DRIVE_KEYS=$DRIVE_KEY_CU
  DIR_KEYS=$DIR_KEY_CU
 else
  # Else remove both HKCR and HKCU entries
  DRIVE_KEYS="$DRIVE_KEY_CR $DRIVE_KEY_CU"
  DIR_KEYS="$DIR_KEY_CR $DIR_KEY_CU"
 fi

 if [ -z "$this_shell" ]; then
  # No shell specified, remove all
  UINST_SHELLS=$KNOWN_SHELLS
 else
  UINST_SHELLS=$this_shell
 fi

 for ushell in $UINST_SHELLS ; do
  for drive in $DRIVE_KEYS ; do
   # Check each key exists before attempting to remove it
   if $REGTOOL_ check $drive/cygwin_$ushell/command 2> /dev/null; then
    if ! $REGTOOL remove $drive/cygwin_$ushell/command ; then
     echo $0 Error: Hive not writable.
     echo Aborting.
     exit
    fi
   fi

   if $REGTOOL_ check $drive/cygwin_$ushell 2> /dev/null; then
    $REGTOOL remove $drive/cygwin_$ushell
   fi
  done

  for dir in $DIR_KEYS ; do
   if $REGTOOL_ check $dir/cygwin_$ushell/command 2> /dev/null; then
    $REGTOOL remove $dir/cygwin_$ushell/command
   fi
   if $REGTOOL_ check $dir/cygwin_$ushell 2> /dev/null; then
    $REGTOOL remove $dir/cygwin_$ushell
   fi
  done

  if $REGTOOL_ check $UINST_KEY/cygwin_$ushell 2> /dev/null; then
   $REGTOOL remove $UINST_KEY/cygwin_$ushell
  fi
 done # shell

 for key in $DRIVE_KEYS $DIR_KEYS ; do
   # Make sure empty KEYs are removed after we've cleared out our entries
   CUR_KEY=$key
   if $REGTOOL_ check $CUR_KEY 2> /dev/null; then
    while [ -n "$CUR_KEY" ]; do
     ENTRIES=`$REGTOOL_ list $CUR_KEY | wc -l`
     if [ $ENTRIES = "0" ] || ( [ $ENTRIES = "1" ] && [ $PRINT = t ] ); then
      # Remove empty key
      $REGTOOL remove $CUR_KEY
     fi
     CUR_KEY=`echo $CUR_KEY | sed "s?/[^/]*\\$??g"`
    done
   fi
 done

fi

if [ $READ = t ]; then
 # Print some useful information
 echo OS is $VER
 echo chere version $VERSION
 if [ -n "$RUN_EXE" ]; then
  echo run.exe is available at $RUN_EXE
 fi
 echo
 for shell in $KNOWN_SHELLS; do
  echo --- $shell keys ---
  #### Directory entries ####
  FOR_WHO="(all users)"
  for dir in $DIR_KEY_CR $DIR_KEY_CU ; do
   if $REGTOOL_ check $dir/cygwin_$shell 2> /dev/null; then
    echo Directory menu item $FOR_WHO
    $REGTOOL get $dir/cygwin_$shell/
    echo
   fi
   if $REGTOOL_ check $dir/cygwin_$shell/command 2> /dev/null; then
    echo Directory command $FOR_WHO
    $REGTOOL get $dir/cygwin_$shell/command/
    echo
   fi
   FOR_WHO="(current user)"
  done
  #### Drive entries ####
  FOR_WHO="(all users)"
  for drive in $DRIVE_KEY_CR $DRIVE_KEY_CU ; do
   if $REGTOOL_ check $drive/cygwin_$shell 2> /dev/null; then
    echo Drive menu item $FOR_WHO
    $REGTOOL get $drive/cygwin_$shell/
    echo
   fi
   if $REGTOOL_ check $drive/cygwin_$shell/command 2> /dev/null; then
    echo Drive command $FOR_WHO
    $REGTOOL get $drive/cygwin_$shell/command/
    echo
   fi
   FOR_WHO="(current user)"
  done
  #### UnInstall entries ####
  if $REGTOOL_ check $UINST_KEY/cygwin_$shell 2> /dev/null; then
    echo Uninstall description
    $REGTOOL get $UINST_KEY/cygwin_$shell/DisplayName
    echo
    echo Uninstall command
    $REGTOOL get $UINST_KEY/cygwin_$shell/UnInstallString
    echo
  fi
  echo
 done
fi

# If requested, list what is currently installed
# Rely on the DIR key rather than UINST key,
# since user may pass -m, or HKLM may not be writable
if [ $LIST = t ]; then
  echo Currently installed Cygwin Here shells \(all users\):
  $REGTOOL_ list $DIR_KEY_CR 2> /dev/null | sed -n 's/cygwin_\(.*\)/\1/gp'
  echo
  echo Currently installed Cygwin Here shells \(current user\):
  $REGTOOL_ list $DIR_KEY_CU 2> /dev/null | sed -n 's/cygwin_\(.*\)/\1/gp'
fi

if [ $ACTION = nothing ] && [ $LIST = f ] && [ $READ = f ]; then
 echo $0: No action taken
 echo Use -h for help
fi